{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}
module Imaggarequest where


import Data.Aeson
import Network.HTTP.Req 
import GHC.Generics
import Data.ByteString as B
import qualified Network.HTTP.Client.MultipartFormData as LM
import Database.PostgreSQL.Simple
import Data.ByteString.Lazy as BS

-- | data type of an image
data ImageDetails = ImageDetails{
    imageId::Int,  -- ^ Unique id for each image in the database
    label :: String,  -- ^ Image label given by user, label is autogenerated when user doesn't provide one
    imagetags :: [ImageTag] 
} deriving(Generic)

data ImageTag = ImageTag{
    confidence :: Double,  -- ^ Confidence score of detected object
    tag :: ImageLabel     -- ^ Name of the detected object in the given image

} deriving(Generic,Show,Eq)

instance FromJSON ImageTag where

data ImageLabel = ImageLabel {
    en::String
    } deriving(Generic,Show,Eq)

instance FromJSON ImageLabel



-- | data type for the request body of the endpoint with Post method
data InputData = InputData{
    url :: String,
    label1 :: String,
    enable :: String  
}deriving(Generic,Show)

instance FromJSON InputData

--return type of post method of imagga
data Image = Image {
    result1 :: Upload
} deriving (Generic,Show)


instance FromJSON Image where
   parseJSON = withObject "Image" $ \v -> Image
        <$> v .: "result"


data Upload = Upload {
    upload_id :: String
} deriving (Generic,Show)


instance FromJSON Upload



fromJust :: Maybe a -> a
fromJust Nothing = error "Maybe.fromJust: Nothing"
fromJust (Just x) = x

main :: IO()
main = do
    useripjson <-BS.readFile "input.json"
    let decodedinp = decode useripjson::Maybe InputData
    let withoutjustinp = fromJust decodedinp

    upload <- uploadImage withoutjustinp
    print upload

 

-- uploadImage :: InputData -> Handler ImageDetails

databaseAdd :: [ImageTag] -> Int -> IO ()
databaseAdd con id = do
   if con /= [] 
       then do
               conn <- initializeConnection
               let en1 = en $ tag $ Prelude.head con 
               let conf = confidence $ Prelude.head con
               execute conn
                    "insert into public.imagetag (id,obj,confidance) values (?,?,?)" (id::Int,en1::String,conf::Double) 
               databaseAdd (Prelude.tail con) id
    else 
        return()



-- uploadImage :: InputData -> IO Image
uploadImage imageurl = do
        let file = url imageurl
        let label = label1 imageurl
        filecontent <- B.readFile file
        let auth = header "Authorization" "Basic YWNjXzQ2YzdjOTU0YTNiZGM0YjphNmY4NmU3NWQwMDcyMmUxNjMxNTI5NmU2MmJhODdiOA=="
        body <-
         reqBodyMultipart
         [ LM.partBS "image_base64" filecontent
          ]
        imaggapost <- runReq defaultHttpConfig $ do
                                    r <-
                                        req
                                        POST
                                        (https "api.imagga.com"/:"v2"/:"uploads")
                                        body
                                        jsonResponse 
                                        auth
                                    return (responseBody r::Image)

        let uploadid = upload_id $ result1 imaggapost
        conn<- initializeConnection
        xs <- query conn
                    "insert into public.imagedetailsnew (imageid,label) values (?,?) returning id" (uploadid::String,label::String) :: IO [Only Int] 
        let imageid = fromOnly $ Prelude.head xs
        result2 <- runReq defaultHttpConfig $ do
                                    let qparam =
                                         "image_upload_id" =: uploadid <>
                                         auth
                                    r <-
                                        req
                                        GET
                                        (https "api.imagga.com"/:"v2"/:"tags")
                                        NoReqBody
                                        jsonResponse 
                                        qparam
                                    return (responseBody r::ImageD)

        let con = tags $result result2
        databaseAdd con imageid


initializeConnection :: IO Connection
initializeConnection = do
  connect defaultConnectInfo {
    connectDatabase = "postgres",
    connectUser = "postgres",
    connectPassword = "Althaf@123"
  }


data ImageD = ImageD {
   result :: ImageDe
      } deriving(Generic,Show)

instance FromJSON ImageD

instance FromJSON ImageDe

data ImageDe = ImageDe{
    tags :: [ImageTag]
   } deriving(Generic,Show)



-- data ImageDet = ImageDet{
--     confidence1 :: Double,
--     tag1 :: InputData1
--     } deriving(Generic,Show,Eq)  

-- instance FromJSON ImageDet

