{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}
module Imaggarequest where

import Control.Monad
import Data.Aeson
import Network.HTTP.Req 
import GHC.Generics
import Data.ByteString as B
import qualified Network.HTTP.Client.MultipartFormData as LM
import Database.PostgreSQL.Simple
import Database.PostgreSQL.Simple.FromRow(FromRow (fromRow),field)
import Data.ByteString.Lazy as BS

-- | data type of an image
data ImageDetails = ImageDetails{
    imageId::Int,  -- ^ Unique id for each image in the database
    label :: String,  -- ^ Image label given by user, label is autogenerated when user doesn't provide one
    imagetags :: [ImageTag] 
} deriving(Generic)

data ImageTag = ImageTag{
    confidence :: Double,  -- ^ Confidence score of detected object
    tag :: ImageLabel     -- ^ Name of the detected object in the given image

} deriving(Generic,Show,Eq)

instance FromJSON ImageTag where

data ImageLabel = ImageLabel {
    en::String
    } deriving(Generic,Show,Eq)

instance FromJSON ImageLabel



-- | data type for the request body of the endpoint with Post method
data InputData = InputData{
    url :: String,
    label1 :: String,
    enable :: String  
}deriving(Generic,Show)

instance FromJSON InputData

--return type of post method of imagga
data Image = Image {
    result1 :: Upload
} deriving (Generic,Show)

data ImageD = ImageD {
   result :: ImageDe
      } deriving(Generic,Show)

instance FromJSON ImageD

instance FromJSON ImageDe

data ImageDe = ImageDe{
    tags :: [ImageTag]
   } deriving(Generic,Show)



instance FromJSON Image where
   parseJSON = withObject "Image" $ \v -> Image
        <$> v .: "result"


data Upload = Upload {
    upload_id :: String
} deriving (Generic,Show)

instance ToJSON InputData
instance FromJSON Upload



fromJust :: Maybe a -> a
fromJust Nothing = error "Maybe.fromJust: Nothing"
fromJust (Just x) = x

main :: IO()
main = do
    useripjson <-BS.readFile "input.json"
    let decodedinp = decode useripjson::Maybe InputData
    let withoutjustinp = fromJust decodedinp

    upload <- uploadImage withoutjustinp
    print upload
   

 

-- uploadImage :: InputData -> Handler ImageDetails

databaseAdd :: [ImageTag] -> Int -> IO ()
databaseAdd con id = do
   if con /= [] 
       then do
               conn <- initializeConnection
               let en1 = en $ tag $ Prelude.head con 
               let conf = confidence $ Prelude.head con
               execute conn
                    "insert into public.imageapi (imageid,obj,confidence) values (?,?,?)" (id::Int,en1::String,conf::Double) 
               databaseAdd (Prelude.tail con) id
    else 
        return()



-- uploadImage :: InputData -> IO Image
uploadImage imageurl = do
        let file = url imageurl
        let label = label1 imageurl
        filecontent <- B.readFile file
        let auth = header "Authorization" "Basic YWNjXzQ2YzdjOTU0YTNiZGM0YjphNmY4NmU3NWQwMDcyMmUxNjMxNTI5NmU2MmJhODdiOA=="
        body <-
         reqBodyMultipart
         [ LM.partBS "image_base64" filecontent
          ]
        imaggapost <- runReq defaultHttpConfig $ do
                                    r <-
                                        req
                                        POST
                                        (https "api.imagga.com"/:"v2"/:"uploads")
                                        body
                                        jsonResponse 
                                        auth
                                    return (responseBody r::Image)

        let uploadid = upload_id $ result1 imaggapost
        conn<- initializeConnection
        xs <- query conn
                    "insert into public.image_details (upload_id,image_label) values (?,?) returning imageid" (uploadid::String,label::String) :: IO [Only Int] 
        let imageid = fromOnly $ Prelude.head xs
        result2 <- runReq defaultHttpConfig $ do
                                    let qparam =
                                         "image_upload_id" =: uploadid <>
                                         auth
                                    r <-
                                        req
                                        GET
                                        (https "api.imagga.com"/:"v2"/:"tags")
                                        NoReqBody
                                        jsonResponse 
                                        qparam
                                    return (responseBody r::ImageD)

        let con = tags $result result2
        recurseList con imageid
        -- databaseAdd con imageid
        -- userResult imageurl imageid

userResult userInput uimageid=do
    let detection= enable userInput
    conn<- initializeConnection
    if (detection=="True")
        then do
            uData<- query conn "select imageapi.imageid,image_label,confidence,obj from image_details\
            \ inner join imageapi on image_details.imageid=imageapi.imageid where imageapi.imageid=? "(Only uimageid)
            let tagss = fmap(\(_,_,outconfidence,outtag) -> ImgTag outconfidence outtag) uData
            let imagedet = (\(imid,imglabel,_,_) -> ImgDetails imid imglabel tagss) $ Prelude.head uData 
            forM_ (tagss ,imagedet)$ \t -> print t

            else do
                fData <- query conn "select imageid,image_label from image_details where imageid = ?" (Only uimageid):: IO [(Int,String)]
                let imgid = fst $ Prelude.head $ fData
               -- print imgid
                let imglabel = snd $ Prelude.head $ fData
                print imglabel
                let idetails = ImgDetails imgid imglabel [ImgTag 0 ""]
                print idetails
                
initializeConnection :: IO Connection
initializeConnection = do
  connect defaultConnectInfo {
    connectDatabase = "postgres",
    connectUser = "postgres",
    connectPassword = "Minnus"
  }

-- | data type for each object in the image
data ImgTag = ImgTag{
    outconfidence :: Double,
     outtag :: String
} deriving(Generic,Show)

-- | data type of an image
data ImgDetails = ImgDetails{
    imid::Int,
    imglabel :: String,
    imgtag :: [ImgTag]
} deriving(Generic,Show)



recurseList taglist imgid = do
   if taglist /= [] 
       then do
               conn <- initializeConnection
               let conf = confidence $ Prelude.head taglist
               let en1 = en $ tag $ Prelude.head taglist 

               let img = fmap(\(_,_,outconfidence,outtag) -> ImgTag outconfidence outtag) conf en1
               let imag = (\(imid,imglabel,_,_) -> ImgDetails imid imglabel tagss) $ 0 "" 
               
               return imag
               recurseList (Prelude.tail taglist) imgid
    else 
        return()